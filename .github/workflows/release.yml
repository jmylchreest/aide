name: Build and Release

on:
  push:
    branches: [main]
    tags: ["v*"]
  pull_request:
    branches: [main]

permissions:
  contents: write
  id-token: write

jobs:
  # Prepare version information
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_tag: ${{ steps.version.outputs.version_tag }}
      is_release: ${{ steps.version.outputs.is_release }}
      should_skip: ${{ steps.version.outputs.should_skip }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          SHOULD_SKIP=false

          # Check if this is a release (tag push)
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            IS_RELEASE=true
            # Strip 'v' prefix from tag: v1.2.3 -> 1.2.3
            VERSION="${GITHUB_REF_NAME#v}"
            VERSION_TAG="${GITHUB_REF_NAME}"
          else
            IS_RELEASE=false

            # For main branch builds, check if this commit already has a release tag
            if [[ "${{ github.ref }}" == refs/heads/main ]]; then
              EXISTING_TAG=$(git tag --points-at HEAD | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1 || true)
              if [[ -n "$EXISTING_TAG" ]]; then
                echo "Commit already has release tag $EXISTING_TAG, skipping build"
                SHOULD_SKIP=true
              fi
            fi

            # Snapshot version: {major}.{minor}.{next_patch}-dev.{commits}+{hash}
            # Use --match 'v*' to skip non-version tags (e.g. 'snapshot')
            if git describe --tags --match 'v*' --always --long 2>/dev/null | grep -q '^v'; then
              DESCRIBE=$(git describe --tags --match 'v*' --always --long 2>/dev/null)
              if [[ $DESCRIBE =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)-([0-9]+)-g([a-f0-9]+)$ ]]; then
                MAJOR=${BASH_REMATCH[1]}
                MINOR=${BASH_REMATCH[2]}
                PATCH=${BASH_REMATCH[3]}
                COMMITS=${BASH_REMATCH[4]}
                HASH=${BASH_REMATCH[5]}
                NEXT_PATCH=$((PATCH + 1))
                VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-dev.${COMMITS}+${HASH}"
                VERSION_TAG="v${MAJOR}.${MINOR}.${NEXT_PATCH}-dev.${COMMITS}"
              else
                # Fallback for unexpected format
                VERSION="0.0.0-dev.0+${GITHUB_SHA:0:7}"
                VERSION_TAG="v0.0.0-dev.0"
              fi
            else
              VERSION="0.0.0-dev.0+${GITHUB_SHA:0:7}"
              VERSION_TAG="v0.0.0-dev.0"
            fi
          fi

          echo "should_skip=${SHOULD_SKIP}" >> $GITHUB_OUTPUT
          echo "is_release=${IS_RELEASE}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT

          echo "Version: ${VERSION}"
          echo "Version Tag: ${VERSION_TAG}"
          echo "Is Release: ${IS_RELEASE}"
          echo "Should Skip: ${SHOULD_SKIP}"

  # Run tests
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should_skip != 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: aide/go.mod
          cache: true
          cache-dependency-path: aide/go.sum

      - name: Run tests
        run: |
          cd aide
          go test -v -race ./...

  # Build binaries for all Claude Code supported platforms
  build:
    name: Build (${{ matrix.goos }}/${{ matrix.goarch }})
    runs-on: ${{ matrix.runner }}
    needs: [prepare, test]
    if: needs.prepare.outputs.should_skip != 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux
          - goos: linux
            goarch: amd64
            runner: ubuntu-latest
            zig_target: x86_64-linux-gnu
          - goos: linux
            goarch: arm64
            runner: ubuntu-latest
            zig_target: aarch64-linux-gnu
          # macOS - native builds on macOS runner (arm64 clang supports both arches)
          - goos: darwin
            goarch: amd64
            runner: macos-latest
          - goos: darwin
            goarch: arm64
            runner: macos-latest
          # Windows
          - goos: windows
            goarch: amd64
            runner: ubuntu-latest
            zig_target: x86_64-windows-gnu
          - goos: windows
            goarch: arm64
            runner: ubuntu-latest
            zig_target: aarch64-windows-gnu
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: aide/go.mod
          cache: true
          cache-dependency-path: aide/go.sum

      - name: Install Zig
        if: matrix.zig_target
        uses: mlugg/setup-zig@v2

      - name: Build
        env:
          CGO_ENABLED: 1
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          cd aide

          # Set zig cross-compiler for Linux/Windows builds
          if [[ -n "${{ matrix.zig_target }}" ]]; then
            export CC="zig cc -target ${{ matrix.zig_target }}"
            export CXX="zig c++ -target ${{ matrix.zig_target }}"
          fi

          # Suppress dllexport redeclaration warnings from upstream go-tree-sitter CGO
          # when cross-compiling for Windows (7 warnings from CGO export header prolog)
          if [[ "${{ matrix.goos }}" == "windows" ]]; then
            export CGO_CFLAGS="-g -O2 -Wno-dll-attribute-on-redeclaration"
          fi

          BINARY_NAME="aide-${{ matrix.goos }}-${{ matrix.goarch }}"
          if [[ "${{ matrix.goos }}" == "windows" ]]; then
            BINARY_NAME="${BINARY_NAME}.exe"
          fi

          go build -ldflags "-s -w \
            -X github.com/jmylchreest/aide/aide/internal/version.Version=${{ needs.prepare.outputs.version }} \
            -X github.com/jmylchreest/aide/aide/internal/version.Commit=${{ github.sha }} \
            -X github.com/jmylchreest/aide/aide/internal/version.Date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            -o "../dist/${BINARY_NAME}" ./cmd/aide

      - name: Compress binary with UPX
        if: matrix.goos != 'darwin' && !(matrix.goos == 'windows' && matrix.goarch == 'arm64')
        uses: svenstaro/upx-action@v2
        with:
          files: |
            dist/aide-*
          args: --best --lzma
          strip: false # Already stripped via -s -w ldflags

      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: aide-${{ matrix.goos }}-${{ matrix.goarch }}
          path: dist/aide-*
          if-no-files-found: error

  # Build tree-sitter grammar shared libraries for dynamic loading
  build-grammars:
    name: Grammars (${{ matrix.os_name }}/${{ matrix.arch }})
    runs-on: ${{ matrix.runner }}
    needs: [prepare]
    if: needs.prepare.outputs.should_skip != 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os_name: linux
            arch: amd64
            runner: ubuntu-latest
            ext: .so
            zig_target: x86_64-linux-gnu
          - os_name: linux
            arch: arm64
            runner: ubuntu-latest
            ext: .so
            zig_target: aarch64-linux-gnu
          - os_name: darwin
            arch: amd64
            runner: macos-latest
            ext: .dylib
          - os_name: darwin
            arch: arm64
            runner: macos-latest
            ext: .dylib
          - os_name: windows
            arch: amd64
            runner: ubuntu-latest
            ext: .dll
            zig_target: x86_64-windows-gnu
          - os_name: windows
            arch: arm64
            runner: ubuntu-latest
            ext: .dll
            zig_target: aarch64-windows-gnu

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Install Zig
        if: matrix.zig_target
        uses: mlugg/setup-zig@v2

      - name: Determine grammar version
        id: gversion
        run: |
          if [[ "${{ needs.prepare.outputs.is_release }}" == "true" ]]; then
            echo "tag=${{ needs.prepare.outputs.version_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=snapshot" >> $GITHUB_OUTPUT
          fi

      - name: Build all grammars
        env:
          VERSION: ${{ steps.gversion.outputs.tag }}
          OS_NAME: ${{ matrix.os_name }}
          ARCH: ${{ matrix.arch }}
          EXT: ${{ matrix.ext }}
          ZIG_TARGET: ${{ matrix.zig_target }}
        run: |
          set -euo pipefail
          mkdir -p dist staging

          # Set compiler as arrays to avoid eval with multi-word commands
          if [[ -n "${ZIG_TARGET:-}" ]]; then
            CC=(zig cc -target "${ZIG_TARGET}")
            SHARED_FLAG="-shared"
          else
            CC=(clang)
            if [[ "${OS_NAME}" == "darwin" ]]; then
              if [[ "${ARCH}" == "arm64" ]]; then
                CC=(clang -arch arm64)
              else
                CC=(clang -arch x86_64)
              fi
              SHARED_FLAG="-dynamiclib"
            else
              SHARED_FLAG="-shared"
            fi
          fi

          # Grammar definitions: name|repo|c_symbol|tag|extra_src_dir
          # Generated from pack.json files â€” update grammars by editing
          # aide/pkg/grammar/packs/<lang>/pack.json, not this array.
          mapfile -t GRAMMARS < <(bash "${GITHUB_WORKSPACE}/scripts/generate-grammar-matrix.sh" --print)

          for entry in "${GRAMMARS[@]}"; do
            IFS='|' read -r name repo c_symbol tag extra_src <<< "$entry"
            echo "=== Building ${name} from ${repo}@${tag} ==="

            git clone --depth 1 --branch "${tag}" "https://github.com/${repo}.git" "grammar-src/${name}" 2>&1 || {
              echo "WARNING: Failed to clone ${repo}@${tag}, skipping ${name}"
              continue
            }

            if [[ -n "${extra_src}" ]]; then
              SRC_DIR="grammar-src/${name}/${extra_src}"
            else
              SRC_DIR="grammar-src/${name}/src"
            fi

            # If parser.c is not in the git tree, try downloading the GitHub
            # release tarball which may include generated files.
            if [[ ! -f "${SRC_DIR}/parser.c" ]]; then
              echo "parser.c not in git tree, trying release tarball..."
              TARBALL_URL="https://github.com/${repo}/releases/download/${tag}/${repo##*/}-${tag}.tar.gz"
              if curl -fsSL "${TARBALL_URL}" -o "/tmp/${name}-release.tar.gz" 2>/dev/null; then
                # Extract only src/ files into the clone directory
                tar -xzf "/tmp/${name}-release.tar.gz" -C "grammar-src/${name}" --strip-components=0 2>/dev/null || true
                rm -f "/tmp/${name}-release.tar.gz"
              fi
            fi

            if [[ ! -f "${SRC_DIR}/parser.c" ]]; then
              echo "WARNING: No parser.c found in ${SRC_DIR}, skipping ${name}"
              rm -rf "grammar-src/${name}"
              continue
            fi

            SOURCES=("${SRC_DIR}/parser.c")
            CXX_SOURCES=()
            if [[ -f "${SRC_DIR}/scanner.c" ]]; then
              SOURCES+=("${SRC_DIR}/scanner.c")
            fi
            # Some grammars use C++ scanners (scanner.cc or scanner.cpp)
            if [[ -f "${SRC_DIR}/scanner.cc" ]]; then
              CXX_SOURCES=("${SRC_DIR}/scanner.cc")
            elif [[ -f "${SRC_DIR}/scanner.cpp" ]]; then
              CXX_SOURCES=("${SRC_DIR}/scanner.cpp")
            fi

            # Compile grammar into a staging directory: staging/{name}/grammar{ext}
            STAGE_DIR="staging/${name}"
            mkdir -p "${STAGE_DIR}"
            GRAMMAR_FILE="${STAGE_DIR}/grammar${EXT}"

            # If there are C++ sources, compile them separately and link together
            if [[ ${#CXX_SOURCES[@]} -gt 0 ]]; then
              # Compile C sources to object files
              "${CC[@]}" -fPIC -O2 -c -I "${SRC_DIR}" -I "grammar-src/${name}/src" \
                "${SOURCES[@]}" 2>&1 || {
                echo "WARNING: Failed to compile C sources for ${name}, skipping"
                rm -rf "grammar-src/${name}" "${STAGE_DIR}"
                continue
              }
              # Determine C++ compiler from CC (replace gcc->g++, clang->clang++)
              CXX=("${CC[@]}")
              CXX[0]="${CXX[0]/gcc/g++}"
              if [[ "${CXX[0]}" == "${CC[0]}" ]]; then
                CXX[0]="${CXX[0]/clang/clang++}"
              fi
              # Compile C++ scanner to object file
              "${CXX[@]}" -fPIC -O2 -c -I "${SRC_DIR}" -I "grammar-src/${name}/src" \
                "${CXX_SOURCES[@]}" 2>&1 || {
                echo "WARNING: Failed to compile C++ scanner for ${name}, skipping"
                rm -f *.o
                rm -rf "grammar-src/${name}" "${STAGE_DIR}"
                continue
              }
              # Link all object files into shared library
              "${CXX[@]}" "${SHARED_FLAG}" -fPIC *.o -o "${GRAMMAR_FILE}" 2>&1 || {
                echo "WARNING: Failed to link ${name}, skipping"
                rm -f *.o
                rm -rf "grammar-src/${name}" "${STAGE_DIR}"
                continue
              }
              rm -f *.o
            else
              "${CC[@]}" "${SHARED_FLAG}" -fPIC -O2 \
                -I "${SRC_DIR}" \
                -I "grammar-src/${name}/src" \
                "${SOURCES[@]}" \
                -o "${GRAMMAR_FILE}" 2>&1 || {
                echo "WARNING: Failed to compile ${name}, skipping"
                rm -rf "grammar-src/${name}" "${STAGE_DIR}"
                continue
              }
            fi

            # Copy pack.json from embedded packs into the staging directory
            PACK_SRC="aide/pkg/grammar/packs/${name}/pack.json"
            if [[ -f "${PACK_SRC}" ]]; then
              cp "${PACK_SRC}" "${STAGE_DIR}/pack.json"
            else
              echo "WARNING: No pack.json found at ${PACK_SRC} for ${name}"
            fi

            # Create .tar.gz archive: {name}/grammar{ext} + {name}/pack.json
            ARCHIVE="dist/aide-grammar-${name}-${VERSION}-${OS_NAME}-${ARCH}.tar.gz"
            tar -czf "${ARCHIVE}" -C staging "${name}"

            ARCHIVE_SIZE=$(stat -c%s "${ARCHIVE}" 2>/dev/null || stat -f%z "${ARCHIVE}")
            GRAMMAR_SIZE=$(stat -c%s "${GRAMMAR_FILE}" 2>/dev/null || stat -f%z "${GRAMMAR_FILE}")
            echo "Packed: ${ARCHIVE} (archive: ${ARCHIVE_SIZE} bytes, grammar: ${GRAMMAR_SIZE} bytes)"

            rm -rf "grammar-src/${name}" "${STAGE_DIR}"
          done

          echo ""
          echo "=== Grammar build summary ==="
          ls -la dist/

      - name: Generate grammar checksums
        working-directory: dist
        run: |
          if command -v sha256sum &>/dev/null; then
            sha256sum aide-grammar-* > grammar-checksums-${{ matrix.os_name }}-${{ matrix.arch }}.txt
          else
            shasum -a 256 aide-grammar-* > grammar-checksums-${{ matrix.os_name }}-${{ matrix.arch }}.txt
          fi

      - name: Upload grammar artifacts
        uses: actions/upload-artifact@v6
        with:
          name: grammars-${{ matrix.os_name }}-${{ matrix.arch }}
          path: |
            dist/aide-grammar-*
            dist/grammar-checksums-*.txt
          if-no-files-found: warn

  # Build the OpenCode plugin npm package
  build-npm:
    name: Build npm package
    runs-on: ubuntu-latest
    needs: [prepare, test]
    if: needs.prepare.outputs.should_skip != 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install

      - name: Build TypeScript
        run: bun run build

      - name: Prepare OpenCode plugin package
        run: bun packages/opencode-plugin/scripts/copy-src.mjs

      - name: Set package version
        working-directory: packages/opencode-plugin
        run: |
          jq '.version = "${{ needs.prepare.outputs.version }}"' package.json > package.json.tmp
          mv package.json.tmp package.json

      - name: Pack tarball
        working-directory: packages/opencode-plugin
        run: bun pm pack

      - name: Upload npm tarball artifact
        uses: actions/upload-artifact@v6
        with:
          name: npm-package
          path: packages/opencode-plugin/jmylchreest-aide-plugin-*.tgz
          if-no-files-found: error

  # Create release (only on tag push)
  release:
    name: Release
    runs-on: ubuntu-latest
    needs: [prepare, build, build-grammars, build-npm]
    if: needs.prepare.outputs.is_release == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download all artifacts
        uses: actions/download-artifact@v7
        with:
          path: artifacts

      - name: Prepare release assets
        run: |
          mkdir -p release
          # Copy Go binaries
          for dir in artifacts/aide-*/; do
            cp "$dir"/* release/ 2>/dev/null || true
          done
          # Copy grammar pack archives (.tar.gz)
          for dir in artifacts/grammars-*/; do
            cp "$dir"/aide-grammar-* release/ 2>/dev/null || true
          done
          # Copy npm tarball
          cp artifacts/npm-package/*.tgz release/ 2>/dev/null || true
          ls -la release/

      - name: Generate checksums
        working-directory: release
        run: |
          sha256sum * > checksums.txt
          cat checksums.txt

      - name: Create release
        uses: softprops/action-gh-release@v2
        with:
          name: aide ${{ needs.prepare.outputs.version_tag }}
          tag_name: ${{ needs.prepare.outputs.version_tag }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            release/aide-*
            release/jmylchreest-aide-plugin-*.tgz
            release/checksums.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Publish to npm (only on tag push, after release)
  publish-npm:
    name: Publish to npm
    runs-on: ubuntu-latest
    needs: [prepare, build-npm, release]
    if: needs.prepare.outputs.is_release == 'true'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org

      - name: Download npm tarball
        uses: actions/download-artifact@v7
        with:
          name: npm-package
          path: artifacts

      - name: Publish to npm with provenance
        run: npm publish ./artifacts/jmylchreest-aide-plugin-*.tgz --provenance --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  # Create snapshot release (on main branch, not tag)
  snapshot:
    name: Snapshot
    runs-on: ubuntu-latest
    needs: [prepare, build, build-grammars, build-npm]
    if: needs.prepare.outputs.is_release == 'false' && github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download all artifacts
        uses: actions/download-artifact@v7
        with:
          path: artifacts

      - name: Prepare release assets
        run: |
          mkdir -p release
          for dir in artifacts/aide-*/; do
            cp "$dir"/* release/ 2>/dev/null || true
          done
          # Copy grammar pack archives (.tar.gz)
          for dir in artifacts/grammars-*/; do
            cp "$dir"/aide-grammar-* release/ 2>/dev/null || true
          done
          cp artifacts/npm-package/*.tgz release/ 2>/dev/null || true
          ls -la release/

      - name: Generate checksums
        working-directory: release
        run: |
          sha256sum * > checksums.txt
          cat checksums.txt

      - name: Delete existing snapshot release
        run: |
          gh release delete snapshot --yes 2>/dev/null || true
          git push origin :refs/tags/snapshot 2>/dev/null || true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create snapshot release
        uses: softprops/action-gh-release@v2
        with:
          name: "Development Snapshot"
          tag_name: snapshot
          draft: false
          prerelease: true
          body: |
            This is an automated development snapshot built from the main branch.

            **Version:** ${{ needs.prepare.outputs.version }}
            **Commit:** ${{ github.sha }}
            **Built:** ${{ github.event.head_commit.timestamp }}

            This release is automatically updated with each push to main.
          files: |
            release/aide-*
            release/jmylchreest-aide-plugin-*.tgz
            release/checksums.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
