// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.1
// source: aidememory.proto

package grpcapi

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MemoryService_Add_FullMethodName    = "/aidememory.MemoryService/Add"
	MemoryService_Get_FullMethodName    = "/aidememory.MemoryService/Get"
	MemoryService_Search_FullMethodName = "/aidememory.MemoryService/Search"
	MemoryService_List_FullMethodName   = "/aidememory.MemoryService/List"
	MemoryService_Delete_FullMethodName = "/aidememory.MemoryService/Delete"
	MemoryService_Clear_FullMethodName  = "/aidememory.MemoryService/Clear"
)

// MemoryServiceClient is the client API for MemoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MemoryServiceClient interface {
	Add(ctx context.Context, in *MemoryAddRequest, opts ...grpc.CallOption) (*MemoryAddResponse, error)
	Get(ctx context.Context, in *MemoryGetRequest, opts ...grpc.CallOption) (*MemoryGetResponse, error)
	Search(ctx context.Context, in *MemorySearchRequest, opts ...grpc.CallOption) (*MemorySearchResponse, error)
	List(ctx context.Context, in *MemoryListRequest, opts ...grpc.CallOption) (*MemoryListResponse, error)
	Delete(ctx context.Context, in *MemoryDeleteRequest, opts ...grpc.CallOption) (*MemoryDeleteResponse, error)
	Clear(ctx context.Context, in *MemoryClearRequest, opts ...grpc.CallOption) (*MemoryClearResponse, error)
}

type memoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMemoryServiceClient(cc grpc.ClientConnInterface) MemoryServiceClient {
	return &memoryServiceClient{cc}
}

func (c *memoryServiceClient) Add(ctx context.Context, in *MemoryAddRequest, opts ...grpc.CallOption) (*MemoryAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryAddResponse)
	err := c.cc.Invoke(ctx, MemoryService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Get(ctx context.Context, in *MemoryGetRequest, opts ...grpc.CallOption) (*MemoryGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryGetResponse)
	err := c.cc.Invoke(ctx, MemoryService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Search(ctx context.Context, in *MemorySearchRequest, opts ...grpc.CallOption) (*MemorySearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemorySearchResponse)
	err := c.cc.Invoke(ctx, MemoryService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) List(ctx context.Context, in *MemoryListRequest, opts ...grpc.CallOption) (*MemoryListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryListResponse)
	err := c.cc.Invoke(ctx, MemoryService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Delete(ctx context.Context, in *MemoryDeleteRequest, opts ...grpc.CallOption) (*MemoryDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryDeleteResponse)
	err := c.cc.Invoke(ctx, MemoryService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Clear(ctx context.Context, in *MemoryClearRequest, opts ...grpc.CallOption) (*MemoryClearResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryClearResponse)
	err := c.cc.Invoke(ctx, MemoryService_Clear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MemoryServiceServer is the server API for MemoryService service.
// All implementations must embed UnimplementedMemoryServiceServer
// for forward compatibility.
type MemoryServiceServer interface {
	Add(context.Context, *MemoryAddRequest) (*MemoryAddResponse, error)
	Get(context.Context, *MemoryGetRequest) (*MemoryGetResponse, error)
	Search(context.Context, *MemorySearchRequest) (*MemorySearchResponse, error)
	List(context.Context, *MemoryListRequest) (*MemoryListResponse, error)
	Delete(context.Context, *MemoryDeleteRequest) (*MemoryDeleteResponse, error)
	Clear(context.Context, *MemoryClearRequest) (*MemoryClearResponse, error)
	mustEmbedUnimplementedMemoryServiceServer()
}

// UnimplementedMemoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMemoryServiceServer struct{}

func (UnimplementedMemoryServiceServer) Add(context.Context, *MemoryAddRequest) (*MemoryAddResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedMemoryServiceServer) Get(context.Context, *MemoryGetRequest) (*MemoryGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMemoryServiceServer) Search(context.Context, *MemorySearchRequest) (*MemorySearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedMemoryServiceServer) List(context.Context, *MemoryListRequest) (*MemoryListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedMemoryServiceServer) Delete(context.Context, *MemoryDeleteRequest) (*MemoryDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMemoryServiceServer) Clear(context.Context, *MemoryClearRequest) (*MemoryClearResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedMemoryServiceServer) mustEmbedUnimplementedMemoryServiceServer() {}
func (UnimplementedMemoryServiceServer) testEmbeddedByValue()                       {}

// UnsafeMemoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MemoryServiceServer will
// result in compilation errors.
type UnsafeMemoryServiceServer interface {
	mustEmbedUnimplementedMemoryServiceServer()
}

func RegisterMemoryServiceServer(s grpc.ServiceRegistrar, srv MemoryServiceServer) {
	// If the following call panics, it indicates UnimplementedMemoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MemoryService_ServiceDesc, srv)
}

func _MemoryService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Add(ctx, req.(*MemoryAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Get(ctx, req.(*MemoryGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemorySearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Search(ctx, req.(*MemorySearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).List(ctx, req.(*MemoryListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Delete(ctx, req.(*MemoryDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Clear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Clear(ctx, req.(*MemoryClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MemoryService_ServiceDesc is the grpc.ServiceDesc for MemoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MemoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.MemoryService",
	HandlerType: (*MemoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _MemoryService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MemoryService_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _MemoryService_Search_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MemoryService_List_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MemoryService_Delete_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _MemoryService_Clear_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	StateService_Get_FullMethodName     = "/aidememory.StateService/Get"
	StateService_Set_FullMethodName     = "/aidememory.StateService/Set"
	StateService_List_FullMethodName    = "/aidememory.StateService/List"
	StateService_Delete_FullMethodName  = "/aidememory.StateService/Delete"
	StateService_Clear_FullMethodName   = "/aidememory.StateService/Clear"
	StateService_Cleanup_FullMethodName = "/aidememory.StateService/Cleanup"
)

// StateServiceClient is the client API for StateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StateServiceClient interface {
	Get(ctx context.Context, in *StateGetRequest, opts ...grpc.CallOption) (*StateGetResponse, error)
	Set(ctx context.Context, in *StateSetRequest, opts ...grpc.CallOption) (*StateSetResponse, error)
	List(ctx context.Context, in *StateListRequest, opts ...grpc.CallOption) (*StateListResponse, error)
	Delete(ctx context.Context, in *StateDeleteRequest, opts ...grpc.CallOption) (*StateDeleteResponse, error)
	Clear(ctx context.Context, in *StateClearRequest, opts ...grpc.CallOption) (*StateClearResponse, error)
	Cleanup(ctx context.Context, in *StateCleanupRequest, opts ...grpc.CallOption) (*StateCleanupResponse, error)
}

type stateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStateServiceClient(cc grpc.ClientConnInterface) StateServiceClient {
	return &stateServiceClient{cc}
}

func (c *stateServiceClient) Get(ctx context.Context, in *StateGetRequest, opts ...grpc.CallOption) (*StateGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateGetResponse)
	err := c.cc.Invoke(ctx, StateService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Set(ctx context.Context, in *StateSetRequest, opts ...grpc.CallOption) (*StateSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateSetResponse)
	err := c.cc.Invoke(ctx, StateService_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) List(ctx context.Context, in *StateListRequest, opts ...grpc.CallOption) (*StateListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateListResponse)
	err := c.cc.Invoke(ctx, StateService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Delete(ctx context.Context, in *StateDeleteRequest, opts ...grpc.CallOption) (*StateDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateDeleteResponse)
	err := c.cc.Invoke(ctx, StateService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Clear(ctx context.Context, in *StateClearRequest, opts ...grpc.CallOption) (*StateClearResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateClearResponse)
	err := c.cc.Invoke(ctx, StateService_Clear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Cleanup(ctx context.Context, in *StateCleanupRequest, opts ...grpc.CallOption) (*StateCleanupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateCleanupResponse)
	err := c.cc.Invoke(ctx, StateService_Cleanup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StateServiceServer is the server API for StateService service.
// All implementations must embed UnimplementedStateServiceServer
// for forward compatibility.
type StateServiceServer interface {
	Get(context.Context, *StateGetRequest) (*StateGetResponse, error)
	Set(context.Context, *StateSetRequest) (*StateSetResponse, error)
	List(context.Context, *StateListRequest) (*StateListResponse, error)
	Delete(context.Context, *StateDeleteRequest) (*StateDeleteResponse, error)
	Clear(context.Context, *StateClearRequest) (*StateClearResponse, error)
	Cleanup(context.Context, *StateCleanupRequest) (*StateCleanupResponse, error)
	mustEmbedUnimplementedStateServiceServer()
}

// UnimplementedStateServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStateServiceServer struct{}

func (UnimplementedStateServiceServer) Get(context.Context, *StateGetRequest) (*StateGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedStateServiceServer) Set(context.Context, *StateSetRequest) (*StateSetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedStateServiceServer) List(context.Context, *StateListRequest) (*StateListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedStateServiceServer) Delete(context.Context, *StateDeleteRequest) (*StateDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedStateServiceServer) Clear(context.Context, *StateClearRequest) (*StateClearResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedStateServiceServer) Cleanup(context.Context, *StateCleanupRequest) (*StateCleanupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Cleanup not implemented")
}
func (UnimplementedStateServiceServer) mustEmbedUnimplementedStateServiceServer() {}
func (UnimplementedStateServiceServer) testEmbeddedByValue()                      {}

// UnsafeStateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StateServiceServer will
// result in compilation errors.
type UnsafeStateServiceServer interface {
	mustEmbedUnimplementedStateServiceServer()
}

func RegisterStateServiceServer(s grpc.ServiceRegistrar, srv StateServiceServer) {
	// If the following call panics, it indicates UnimplementedStateServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StateService_ServiceDesc, srv)
}

func _StateService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Get(ctx, req.(*StateGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Set(ctx, req.(*StateSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).List(ctx, req.(*StateListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Delete(ctx, req.(*StateDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Clear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Clear(ctx, req.(*StateClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateCleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Cleanup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Cleanup(ctx, req.(*StateCleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StateService_ServiceDesc is the grpc.ServiceDesc for StateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.StateService",
	HandlerType: (*StateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _StateService_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _StateService_Set_Handler,
		},
		{
			MethodName: "List",
			Handler:    _StateService_List_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _StateService_Delete_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _StateService_Clear_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _StateService_Cleanup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	DecisionService_Set_FullMethodName     = "/aidememory.DecisionService/Set"
	DecisionService_Get_FullMethodName     = "/aidememory.DecisionService/Get"
	DecisionService_List_FullMethodName    = "/aidememory.DecisionService/List"
	DecisionService_History_FullMethodName = "/aidememory.DecisionService/History"
	DecisionService_Delete_FullMethodName  = "/aidememory.DecisionService/Delete"
	DecisionService_Clear_FullMethodName   = "/aidememory.DecisionService/Clear"
)

// DecisionServiceClient is the client API for DecisionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DecisionServiceClient interface {
	Set(ctx context.Context, in *DecisionSetRequest, opts ...grpc.CallOption) (*DecisionSetResponse, error)
	Get(ctx context.Context, in *DecisionGetRequest, opts ...grpc.CallOption) (*DecisionGetResponse, error)
	List(ctx context.Context, in *DecisionListRequest, opts ...grpc.CallOption) (*DecisionListResponse, error)
	History(ctx context.Context, in *DecisionHistoryRequest, opts ...grpc.CallOption) (*DecisionHistoryResponse, error)
	Delete(ctx context.Context, in *DecisionDeleteRequest, opts ...grpc.CallOption) (*DecisionDeleteResponse, error)
	Clear(ctx context.Context, in *DecisionClearRequest, opts ...grpc.CallOption) (*DecisionClearResponse, error)
}

type decisionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDecisionServiceClient(cc grpc.ClientConnInterface) DecisionServiceClient {
	return &decisionServiceClient{cc}
}

func (c *decisionServiceClient) Set(ctx context.Context, in *DecisionSetRequest, opts ...grpc.CallOption) (*DecisionSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionSetResponse)
	err := c.cc.Invoke(ctx, DecisionService_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decisionServiceClient) Get(ctx context.Context, in *DecisionGetRequest, opts ...grpc.CallOption) (*DecisionGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionGetResponse)
	err := c.cc.Invoke(ctx, DecisionService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decisionServiceClient) List(ctx context.Context, in *DecisionListRequest, opts ...grpc.CallOption) (*DecisionListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionListResponse)
	err := c.cc.Invoke(ctx, DecisionService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decisionServiceClient) History(ctx context.Context, in *DecisionHistoryRequest, opts ...grpc.CallOption) (*DecisionHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionHistoryResponse)
	err := c.cc.Invoke(ctx, DecisionService_History_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decisionServiceClient) Delete(ctx context.Context, in *DecisionDeleteRequest, opts ...grpc.CallOption) (*DecisionDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionDeleteResponse)
	err := c.cc.Invoke(ctx, DecisionService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decisionServiceClient) Clear(ctx context.Context, in *DecisionClearRequest, opts ...grpc.CallOption) (*DecisionClearResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionClearResponse)
	err := c.cc.Invoke(ctx, DecisionService_Clear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DecisionServiceServer is the server API for DecisionService service.
// All implementations must embed UnimplementedDecisionServiceServer
// for forward compatibility.
type DecisionServiceServer interface {
	Set(context.Context, *DecisionSetRequest) (*DecisionSetResponse, error)
	Get(context.Context, *DecisionGetRequest) (*DecisionGetResponse, error)
	List(context.Context, *DecisionListRequest) (*DecisionListResponse, error)
	History(context.Context, *DecisionHistoryRequest) (*DecisionHistoryResponse, error)
	Delete(context.Context, *DecisionDeleteRequest) (*DecisionDeleteResponse, error)
	Clear(context.Context, *DecisionClearRequest) (*DecisionClearResponse, error)
	mustEmbedUnimplementedDecisionServiceServer()
}

// UnimplementedDecisionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDecisionServiceServer struct{}

func (UnimplementedDecisionServiceServer) Set(context.Context, *DecisionSetRequest) (*DecisionSetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedDecisionServiceServer) Get(context.Context, *DecisionGetRequest) (*DecisionGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDecisionServiceServer) List(context.Context, *DecisionListRequest) (*DecisionListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDecisionServiceServer) History(context.Context, *DecisionHistoryRequest) (*DecisionHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method History not implemented")
}
func (UnimplementedDecisionServiceServer) Delete(context.Context, *DecisionDeleteRequest) (*DecisionDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDecisionServiceServer) Clear(context.Context, *DecisionClearRequest) (*DecisionClearResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedDecisionServiceServer) mustEmbedUnimplementedDecisionServiceServer() {}
func (UnimplementedDecisionServiceServer) testEmbeddedByValue()                         {}

// UnsafeDecisionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DecisionServiceServer will
// result in compilation errors.
type UnsafeDecisionServiceServer interface {
	mustEmbedUnimplementedDecisionServiceServer()
}

func RegisterDecisionServiceServer(s grpc.ServiceRegistrar, srv DecisionServiceServer) {
	// If the following call panics, it indicates UnimplementedDecisionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DecisionService_ServiceDesc, srv)
}

func _DecisionService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).Set(ctx, req.(*DecisionSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecisionService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).Get(ctx, req.(*DecisionGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecisionService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).List(ctx, req.(*DecisionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecisionService_History_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).History(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_History_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).History(ctx, req.(*DecisionHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecisionService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).Delete(ctx, req.(*DecisionDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecisionService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_Clear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).Clear(ctx, req.(*DecisionClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DecisionService_ServiceDesc is the grpc.ServiceDesc for DecisionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DecisionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.DecisionService",
	HandlerType: (*DecisionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _DecisionService_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DecisionService_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DecisionService_List_Handler,
		},
		{
			MethodName: "History",
			Handler:    _DecisionService_History_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DecisionService_Delete_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _DecisionService_Clear_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	MessageService_Send_FullMethodName  = "/aidememory.MessageService/Send"
	MessageService_List_FullMethodName  = "/aidememory.MessageService/List"
	MessageService_Ack_FullMethodName   = "/aidememory.MessageService/Ack"
	MessageService_Prune_FullMethodName = "/aidememory.MessageService/Prune"
)

// MessageServiceClient is the client API for MessageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MessageServiceClient interface {
	Send(ctx context.Context, in *MessageSendRequest, opts ...grpc.CallOption) (*MessageSendResponse, error)
	List(ctx context.Context, in *MessageListRequest, opts ...grpc.CallOption) (*MessageListResponse, error)
	Ack(ctx context.Context, in *MessageAckRequest, opts ...grpc.CallOption) (*MessageAckResponse, error)
	Prune(ctx context.Context, in *MessagePruneRequest, opts ...grpc.CallOption) (*MessagePruneResponse, error)
}

type messageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageServiceClient(cc grpc.ClientConnInterface) MessageServiceClient {
	return &messageServiceClient{cc}
}

func (c *messageServiceClient) Send(ctx context.Context, in *MessageSendRequest, opts ...grpc.CallOption) (*MessageSendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageSendResponse)
	err := c.cc.Invoke(ctx, MessageService_Send_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) List(ctx context.Context, in *MessageListRequest, opts ...grpc.CallOption) (*MessageListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageListResponse)
	err := c.cc.Invoke(ctx, MessageService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) Ack(ctx context.Context, in *MessageAckRequest, opts ...grpc.CallOption) (*MessageAckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageAckResponse)
	err := c.cc.Invoke(ctx, MessageService_Ack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) Prune(ctx context.Context, in *MessagePruneRequest, opts ...grpc.CallOption) (*MessagePruneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessagePruneResponse)
	err := c.cc.Invoke(ctx, MessageService_Prune_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageServiceServer is the server API for MessageService service.
// All implementations must embed UnimplementedMessageServiceServer
// for forward compatibility.
type MessageServiceServer interface {
	Send(context.Context, *MessageSendRequest) (*MessageSendResponse, error)
	List(context.Context, *MessageListRequest) (*MessageListResponse, error)
	Ack(context.Context, *MessageAckRequest) (*MessageAckResponse, error)
	Prune(context.Context, *MessagePruneRequest) (*MessagePruneResponse, error)
	mustEmbedUnimplementedMessageServiceServer()
}

// UnimplementedMessageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMessageServiceServer struct{}

func (UnimplementedMessageServiceServer) Send(context.Context, *MessageSendRequest) (*MessageSendResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedMessageServiceServer) List(context.Context, *MessageListRequest) (*MessageListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedMessageServiceServer) Ack(context.Context, *MessageAckRequest) (*MessageAckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ack not implemented")
}
func (UnimplementedMessageServiceServer) Prune(context.Context, *MessagePruneRequest) (*MessagePruneResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Prune not implemented")
}
func (UnimplementedMessageServiceServer) mustEmbedUnimplementedMessageServiceServer() {}
func (UnimplementedMessageServiceServer) testEmbeddedByValue()                        {}

// UnsafeMessageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageServiceServer will
// result in compilation errors.
type UnsafeMessageServiceServer interface {
	mustEmbedUnimplementedMessageServiceServer()
}

func RegisterMessageServiceServer(s grpc.ServiceRegistrar, srv MessageServiceServer) {
	// If the following call panics, it indicates UnimplementedMessageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MessageService_ServiceDesc, srv)
}

func _MessageService_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageSendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Send(ctx, req.(*MessageSendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).List(ctx, req.(*MessageListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageAckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Ack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Ack(ctx, req.(*MessageAckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_Prune_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagePruneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Prune(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Prune_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Prune(ctx, req.(*MessagePruneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MessageService_ServiceDesc is the grpc.ServiceDesc for MessageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MessageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.MessageService",
	HandlerType: (*MessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _MessageService_Send_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MessageService_List_Handler,
		},
		{
			MethodName: "Ack",
			Handler:    _MessageService_Ack_Handler,
		},
		{
			MethodName: "Prune",
			Handler:    _MessageService_Prune_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	TaskService_Create_FullMethodName   = "/aidememory.TaskService/Create"
	TaskService_Get_FullMethodName      = "/aidememory.TaskService/Get"
	TaskService_List_FullMethodName     = "/aidememory.TaskService/List"
	TaskService_Claim_FullMethodName    = "/aidememory.TaskService/Claim"
	TaskService_Complete_FullMethodName = "/aidememory.TaskService/Complete"
	TaskService_Update_FullMethodName   = "/aidememory.TaskService/Update"
)

// TaskServiceClient is the client API for TaskService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskServiceClient interface {
	Create(ctx context.Context, in *TaskCreateRequest, opts ...grpc.CallOption) (*TaskCreateResponse, error)
	Get(ctx context.Context, in *TaskGetRequest, opts ...grpc.CallOption) (*TaskGetResponse, error)
	List(ctx context.Context, in *TaskListRequest, opts ...grpc.CallOption) (*TaskListResponse, error)
	Claim(ctx context.Context, in *TaskClaimRequest, opts ...grpc.CallOption) (*TaskClaimResponse, error)
	Complete(ctx context.Context, in *TaskCompleteRequest, opts ...grpc.CallOption) (*TaskCompleteResponse, error)
	Update(ctx context.Context, in *TaskUpdateRequest, opts ...grpc.CallOption) (*TaskUpdateResponse, error)
}

type taskServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskServiceClient(cc grpc.ClientConnInterface) TaskServiceClient {
	return &taskServiceClient{cc}
}

func (c *taskServiceClient) Create(ctx context.Context, in *TaskCreateRequest, opts ...grpc.CallOption) (*TaskCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskCreateResponse)
	err := c.cc.Invoke(ctx, TaskService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) Get(ctx context.Context, in *TaskGetRequest, opts ...grpc.CallOption) (*TaskGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskGetResponse)
	err := c.cc.Invoke(ctx, TaskService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) List(ctx context.Context, in *TaskListRequest, opts ...grpc.CallOption) (*TaskListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskListResponse)
	err := c.cc.Invoke(ctx, TaskService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) Claim(ctx context.Context, in *TaskClaimRequest, opts ...grpc.CallOption) (*TaskClaimResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskClaimResponse)
	err := c.cc.Invoke(ctx, TaskService_Claim_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) Complete(ctx context.Context, in *TaskCompleteRequest, opts ...grpc.CallOption) (*TaskCompleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskCompleteResponse)
	err := c.cc.Invoke(ctx, TaskService_Complete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) Update(ctx context.Context, in *TaskUpdateRequest, opts ...grpc.CallOption) (*TaskUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskUpdateResponse)
	err := c.cc.Invoke(ctx, TaskService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskServiceServer is the server API for TaskService service.
// All implementations must embed UnimplementedTaskServiceServer
// for forward compatibility.
type TaskServiceServer interface {
	Create(context.Context, *TaskCreateRequest) (*TaskCreateResponse, error)
	Get(context.Context, *TaskGetRequest) (*TaskGetResponse, error)
	List(context.Context, *TaskListRequest) (*TaskListResponse, error)
	Claim(context.Context, *TaskClaimRequest) (*TaskClaimResponse, error)
	Complete(context.Context, *TaskCompleteRequest) (*TaskCompleteResponse, error)
	Update(context.Context, *TaskUpdateRequest) (*TaskUpdateResponse, error)
	mustEmbedUnimplementedTaskServiceServer()
}

// UnimplementedTaskServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskServiceServer struct{}

func (UnimplementedTaskServiceServer) Create(context.Context, *TaskCreateRequest) (*TaskCreateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTaskServiceServer) Get(context.Context, *TaskGetRequest) (*TaskGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTaskServiceServer) List(context.Context, *TaskListRequest) (*TaskListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTaskServiceServer) Claim(context.Context, *TaskClaimRequest) (*TaskClaimResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Claim not implemented")
}
func (UnimplementedTaskServiceServer) Complete(context.Context, *TaskCompleteRequest) (*TaskCompleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Complete not implemented")
}
func (UnimplementedTaskServiceServer) Update(context.Context, *TaskUpdateRequest) (*TaskUpdateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTaskServiceServer) mustEmbedUnimplementedTaskServiceServer() {}
func (UnimplementedTaskServiceServer) testEmbeddedByValue()                     {}

// UnsafeTaskServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskServiceServer will
// result in compilation errors.
type UnsafeTaskServiceServer interface {
	mustEmbedUnimplementedTaskServiceServer()
}

func RegisterTaskServiceServer(s grpc.ServiceRegistrar, srv TaskServiceServer) {
	// If the following call panics, it indicates UnimplementedTaskServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TaskService_ServiceDesc, srv)
}

func _TaskService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Create(ctx, req.(*TaskCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Get(ctx, req.(*TaskGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).List(ctx, req.(*TaskListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_Claim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskClaimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Claim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Claim_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Claim(ctx, req.(*TaskClaimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_Complete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Complete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Complete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Complete(ctx, req.(*TaskCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Update(ctx, req.(*TaskUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskService_ServiceDesc is the grpc.ServiceDesc for TaskService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.TaskService",
	HandlerType: (*TaskServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _TaskService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TaskService_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TaskService_List_Handler,
		},
		{
			MethodName: "Claim",
			Handler:    _TaskService_Claim_Handler,
		},
		{
			MethodName: "Complete",
			Handler:    _TaskService_Complete_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _TaskService_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	CodeService_Search_FullMethodName  = "/aidememory.CodeService/Search"
	CodeService_Symbols_FullMethodName = "/aidememory.CodeService/Symbols"
	CodeService_Stats_FullMethodName   = "/aidememory.CodeService/Stats"
	CodeService_Index_FullMethodName   = "/aidememory.CodeService/Index"
	CodeService_Clear_FullMethodName   = "/aidememory.CodeService/Clear"
)

// CodeServiceClient is the client API for CodeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CodeServiceClient interface {
	Search(ctx context.Context, in *CodeSearchRequest, opts ...grpc.CallOption) (*CodeSearchResponse, error)
	Symbols(ctx context.Context, in *CodeSymbolsRequest, opts ...grpc.CallOption) (*CodeSymbolsResponse, error)
	Stats(ctx context.Context, in *CodeStatsRequest, opts ...grpc.CallOption) (*CodeStatsResponse, error)
	Index(ctx context.Context, in *CodeIndexRequest, opts ...grpc.CallOption) (*CodeIndexResponse, error)
	Clear(ctx context.Context, in *CodeClearRequest, opts ...grpc.CallOption) (*CodeClearResponse, error)
}

type codeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCodeServiceClient(cc grpc.ClientConnInterface) CodeServiceClient {
	return &codeServiceClient{cc}
}

func (c *codeServiceClient) Search(ctx context.Context, in *CodeSearchRequest, opts ...grpc.CallOption) (*CodeSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeSearchResponse)
	err := c.cc.Invoke(ctx, CodeService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeServiceClient) Symbols(ctx context.Context, in *CodeSymbolsRequest, opts ...grpc.CallOption) (*CodeSymbolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeSymbolsResponse)
	err := c.cc.Invoke(ctx, CodeService_Symbols_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeServiceClient) Stats(ctx context.Context, in *CodeStatsRequest, opts ...grpc.CallOption) (*CodeStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeStatsResponse)
	err := c.cc.Invoke(ctx, CodeService_Stats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeServiceClient) Index(ctx context.Context, in *CodeIndexRequest, opts ...grpc.CallOption) (*CodeIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeIndexResponse)
	err := c.cc.Invoke(ctx, CodeService_Index_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeServiceClient) Clear(ctx context.Context, in *CodeClearRequest, opts ...grpc.CallOption) (*CodeClearResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeClearResponse)
	err := c.cc.Invoke(ctx, CodeService_Clear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CodeServiceServer is the server API for CodeService service.
// All implementations must embed UnimplementedCodeServiceServer
// for forward compatibility.
type CodeServiceServer interface {
	Search(context.Context, *CodeSearchRequest) (*CodeSearchResponse, error)
	Symbols(context.Context, *CodeSymbolsRequest) (*CodeSymbolsResponse, error)
	Stats(context.Context, *CodeStatsRequest) (*CodeStatsResponse, error)
	Index(context.Context, *CodeIndexRequest) (*CodeIndexResponse, error)
	Clear(context.Context, *CodeClearRequest) (*CodeClearResponse, error)
	mustEmbedUnimplementedCodeServiceServer()
}

// UnimplementedCodeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCodeServiceServer struct{}

func (UnimplementedCodeServiceServer) Search(context.Context, *CodeSearchRequest) (*CodeSearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedCodeServiceServer) Symbols(context.Context, *CodeSymbolsRequest) (*CodeSymbolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Symbols not implemented")
}
func (UnimplementedCodeServiceServer) Stats(context.Context, *CodeStatsRequest) (*CodeStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Stats not implemented")
}
func (UnimplementedCodeServiceServer) Index(context.Context, *CodeIndexRequest) (*CodeIndexResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedCodeServiceServer) Clear(context.Context, *CodeClearRequest) (*CodeClearResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedCodeServiceServer) mustEmbedUnimplementedCodeServiceServer() {}
func (UnimplementedCodeServiceServer) testEmbeddedByValue()                     {}

// UnsafeCodeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CodeServiceServer will
// result in compilation errors.
type UnsafeCodeServiceServer interface {
	mustEmbedUnimplementedCodeServiceServer()
}

func RegisterCodeServiceServer(s grpc.ServiceRegistrar, srv CodeServiceServer) {
	// If the following call panics, it indicates UnimplementedCodeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CodeService_ServiceDesc, srv)
}

func _CodeService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodeSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeServiceServer).Search(ctx, req.(*CodeSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeService_Symbols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodeSymbolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeServiceServer).Symbols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeService_Symbols_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeServiceServer).Symbols(ctx, req.(*CodeSymbolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeService_Stats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodeStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeServiceServer).Stats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeService_Stats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeServiceServer).Stats(ctx, req.(*CodeStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeService_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodeIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeServiceServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeService_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeServiceServer).Index(ctx, req.(*CodeIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodeClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeService_Clear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeServiceServer).Clear(ctx, req.(*CodeClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CodeService_ServiceDesc is the grpc.ServiceDesc for CodeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CodeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.CodeService",
	HandlerType: (*CodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _CodeService_Search_Handler,
		},
		{
			MethodName: "Symbols",
			Handler:    _CodeService_Symbols_Handler,
		},
		{
			MethodName: "Stats",
			Handler:    _CodeService_Stats_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _CodeService_Index_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _CodeService_Clear_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	FindingsService_Add_FullMethodName             = "/aidememory.FindingsService/Add"
	FindingsService_Get_FullMethodName             = "/aidememory.FindingsService/Get"
	FindingsService_Delete_FullMethodName          = "/aidememory.FindingsService/Delete"
	FindingsService_Search_FullMethodName          = "/aidememory.FindingsService/Search"
	FindingsService_List_FullMethodName            = "/aidememory.FindingsService/List"
	FindingsService_GetFileFindings_FullMethodName = "/aidememory.FindingsService/GetFileFindings"
	FindingsService_ClearAnalyzer_FullMethodName   = "/aidememory.FindingsService/ClearAnalyzer"
	FindingsService_Stats_FullMethodName           = "/aidememory.FindingsService/Stats"
	FindingsService_Clear_FullMethodName           = "/aidememory.FindingsService/Clear"
)

// FindingsServiceClient is the client API for FindingsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FindingsServiceClient interface {
	Add(ctx context.Context, in *FindingAddRequest, opts ...grpc.CallOption) (*FindingAddResponse, error)
	Get(ctx context.Context, in *FindingGetRequest, opts ...grpc.CallOption) (*FindingGetResponse, error)
	Delete(ctx context.Context, in *FindingDeleteRequest, opts ...grpc.CallOption) (*FindingDeleteResponse, error)
	Search(ctx context.Context, in *FindingSearchRequest, opts ...grpc.CallOption) (*FindingSearchResponse, error)
	List(ctx context.Context, in *FindingListRequest, opts ...grpc.CallOption) (*FindingSearchResponse, error)
	GetFileFindings(ctx context.Context, in *FindingFileRequest, opts ...grpc.CallOption) (*FindingSearchResponse, error)
	ClearAnalyzer(ctx context.Context, in *FindingClearAnalyzerRequest, opts ...grpc.CallOption) (*FindingClearAnalyzerResponse, error)
	Stats(ctx context.Context, in *FindingStatsRequest, opts ...grpc.CallOption) (*FindingStatsResponse, error)
	Clear(ctx context.Context, in *FindingClearRequest, opts ...grpc.CallOption) (*FindingClearResponse, error)
}

type findingsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFindingsServiceClient(cc grpc.ClientConnInterface) FindingsServiceClient {
	return &findingsServiceClient{cc}
}

func (c *findingsServiceClient) Add(ctx context.Context, in *FindingAddRequest, opts ...grpc.CallOption) (*FindingAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindingAddResponse)
	err := c.cc.Invoke(ctx, FindingsService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *findingsServiceClient) Get(ctx context.Context, in *FindingGetRequest, opts ...grpc.CallOption) (*FindingGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindingGetResponse)
	err := c.cc.Invoke(ctx, FindingsService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *findingsServiceClient) Delete(ctx context.Context, in *FindingDeleteRequest, opts ...grpc.CallOption) (*FindingDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindingDeleteResponse)
	err := c.cc.Invoke(ctx, FindingsService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *findingsServiceClient) Search(ctx context.Context, in *FindingSearchRequest, opts ...grpc.CallOption) (*FindingSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindingSearchResponse)
	err := c.cc.Invoke(ctx, FindingsService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *findingsServiceClient) List(ctx context.Context, in *FindingListRequest, opts ...grpc.CallOption) (*FindingSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindingSearchResponse)
	err := c.cc.Invoke(ctx, FindingsService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *findingsServiceClient) GetFileFindings(ctx context.Context, in *FindingFileRequest, opts ...grpc.CallOption) (*FindingSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindingSearchResponse)
	err := c.cc.Invoke(ctx, FindingsService_GetFileFindings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *findingsServiceClient) ClearAnalyzer(ctx context.Context, in *FindingClearAnalyzerRequest, opts ...grpc.CallOption) (*FindingClearAnalyzerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindingClearAnalyzerResponse)
	err := c.cc.Invoke(ctx, FindingsService_ClearAnalyzer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *findingsServiceClient) Stats(ctx context.Context, in *FindingStatsRequest, opts ...grpc.CallOption) (*FindingStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindingStatsResponse)
	err := c.cc.Invoke(ctx, FindingsService_Stats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *findingsServiceClient) Clear(ctx context.Context, in *FindingClearRequest, opts ...grpc.CallOption) (*FindingClearResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindingClearResponse)
	err := c.cc.Invoke(ctx, FindingsService_Clear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FindingsServiceServer is the server API for FindingsService service.
// All implementations must embed UnimplementedFindingsServiceServer
// for forward compatibility.
type FindingsServiceServer interface {
	Add(context.Context, *FindingAddRequest) (*FindingAddResponse, error)
	Get(context.Context, *FindingGetRequest) (*FindingGetResponse, error)
	Delete(context.Context, *FindingDeleteRequest) (*FindingDeleteResponse, error)
	Search(context.Context, *FindingSearchRequest) (*FindingSearchResponse, error)
	List(context.Context, *FindingListRequest) (*FindingSearchResponse, error)
	GetFileFindings(context.Context, *FindingFileRequest) (*FindingSearchResponse, error)
	ClearAnalyzer(context.Context, *FindingClearAnalyzerRequest) (*FindingClearAnalyzerResponse, error)
	Stats(context.Context, *FindingStatsRequest) (*FindingStatsResponse, error)
	Clear(context.Context, *FindingClearRequest) (*FindingClearResponse, error)
	mustEmbedUnimplementedFindingsServiceServer()
}

// UnimplementedFindingsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFindingsServiceServer struct{}

func (UnimplementedFindingsServiceServer) Add(context.Context, *FindingAddRequest) (*FindingAddResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFindingsServiceServer) Get(context.Context, *FindingGetRequest) (*FindingGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFindingsServiceServer) Delete(context.Context, *FindingDeleteRequest) (*FindingDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedFindingsServiceServer) Search(context.Context, *FindingSearchRequest) (*FindingSearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedFindingsServiceServer) List(context.Context, *FindingListRequest) (*FindingSearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedFindingsServiceServer) GetFileFindings(context.Context, *FindingFileRequest) (*FindingSearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFileFindings not implemented")
}
func (UnimplementedFindingsServiceServer) ClearAnalyzer(context.Context, *FindingClearAnalyzerRequest) (*FindingClearAnalyzerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearAnalyzer not implemented")
}
func (UnimplementedFindingsServiceServer) Stats(context.Context, *FindingStatsRequest) (*FindingStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Stats not implemented")
}
func (UnimplementedFindingsServiceServer) Clear(context.Context, *FindingClearRequest) (*FindingClearResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedFindingsServiceServer) mustEmbedUnimplementedFindingsServiceServer() {}
func (UnimplementedFindingsServiceServer) testEmbeddedByValue()                         {}

// UnsafeFindingsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FindingsServiceServer will
// result in compilation errors.
type UnsafeFindingsServiceServer interface {
	mustEmbedUnimplementedFindingsServiceServer()
}

func RegisterFindingsServiceServer(s grpc.ServiceRegistrar, srv FindingsServiceServer) {
	// If the following call panics, it indicates UnimplementedFindingsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FindingsService_ServiceDesc, srv)
}

func _FindingsService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindingAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FindingsServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FindingsService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FindingsServiceServer).Add(ctx, req.(*FindingAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FindingsService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindingGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FindingsServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FindingsService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FindingsServiceServer).Get(ctx, req.(*FindingGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FindingsService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindingDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FindingsServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FindingsService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FindingsServiceServer).Delete(ctx, req.(*FindingDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FindingsService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindingSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FindingsServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FindingsService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FindingsServiceServer).Search(ctx, req.(*FindingSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FindingsService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindingListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FindingsServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FindingsService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FindingsServiceServer).List(ctx, req.(*FindingListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FindingsService_GetFileFindings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindingFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FindingsServiceServer).GetFileFindings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FindingsService_GetFileFindings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FindingsServiceServer).GetFileFindings(ctx, req.(*FindingFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FindingsService_ClearAnalyzer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindingClearAnalyzerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FindingsServiceServer).ClearAnalyzer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FindingsService_ClearAnalyzer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FindingsServiceServer).ClearAnalyzer(ctx, req.(*FindingClearAnalyzerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FindingsService_Stats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindingStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FindingsServiceServer).Stats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FindingsService_Stats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FindingsServiceServer).Stats(ctx, req.(*FindingStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FindingsService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindingClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FindingsServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FindingsService_Clear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FindingsServiceServer).Clear(ctx, req.(*FindingClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FindingsService_ServiceDesc is the grpc.ServiceDesc for FindingsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FindingsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.FindingsService",
	HandlerType: (*FindingsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FindingsService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FindingsService_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FindingsService_Delete_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _FindingsService_Search_Handler,
		},
		{
			MethodName: "List",
			Handler:    _FindingsService_List_Handler,
		},
		{
			MethodName: "GetFileFindings",
			Handler:    _FindingsService_GetFileFindings_Handler,
		},
		{
			MethodName: "ClearAnalyzer",
			Handler:    _FindingsService_ClearAnalyzer_Handler,
		},
		{
			MethodName: "Stats",
			Handler:    _FindingsService_Stats_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _FindingsService_Clear_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	HealthService_Check_FullMethodName = "/aidememory.HealthService/Check"
)

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthServiceClient interface {
	Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthService_Check_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility.
type HealthServiceServer interface {
	Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthServiceServer struct{}

func (UnimplementedHealthServiceServer) Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}
func (UnimplementedHealthServiceServer) testEmbeddedByValue()                       {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	// If the following call panics, it indicates UnimplementedHealthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_Check_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Check(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _HealthService_Check_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	StatusService_GetStatus_FullMethodName = "/aidememory.StatusService/GetStatus"
)

// StatusServiceClient is the client API for StatusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StatusServiceClient interface {
	GetStatus(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type statusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStatusServiceClient(cc grpc.ClientConnInterface) StatusServiceClient {
	return &statusServiceClient{cc}
}

func (c *statusServiceClient) GetStatus(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, StatusService_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StatusServiceServer is the server API for StatusService service.
// All implementations must embed UnimplementedStatusServiceServer
// for forward compatibility.
type StatusServiceServer interface {
	GetStatus(context.Context, *StatusRequest) (*StatusResponse, error)
	mustEmbedUnimplementedStatusServiceServer()
}

// UnimplementedStatusServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStatusServiceServer struct{}

func (UnimplementedStatusServiceServer) GetStatus(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedStatusServiceServer) mustEmbedUnimplementedStatusServiceServer() {}
func (UnimplementedStatusServiceServer) testEmbeddedByValue()                       {}

// UnsafeStatusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StatusServiceServer will
// result in compilation errors.
type UnsafeStatusServiceServer interface {
	mustEmbedUnimplementedStatusServiceServer()
}

func RegisterStatusServiceServer(s grpc.ServiceRegistrar, srv StatusServiceServer) {
	// If the following call panics, it indicates UnimplementedStatusServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StatusService_ServiceDesc, srv)
}

func _StatusService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StatusService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServiceServer).GetStatus(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StatusService_ServiceDesc is the grpc.ServiceDesc for StatusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StatusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.StatusService",
	HandlerType: (*StatusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStatus",
			Handler:    _StatusService_GetStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}
