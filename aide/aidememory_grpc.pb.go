// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.1
// source: aidememory.proto

package grpcapi

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MemoryService_Add_FullMethodName    = "/aidememory.MemoryService/Add"
	MemoryService_Get_FullMethodName    = "/aidememory.MemoryService/Get"
	MemoryService_Search_FullMethodName = "/aidememory.MemoryService/Search"
	MemoryService_List_FullMethodName   = "/aidememory.MemoryService/List"
	MemoryService_Delete_FullMethodName = "/aidememory.MemoryService/Delete"
)

// MemoryServiceClient is the client API for MemoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MemoryServiceClient interface {
	Add(ctx context.Context, in *MemoryAddRequest, opts ...grpc.CallOption) (*MemoryAddResponse, error)
	Get(ctx context.Context, in *MemoryGetRequest, opts ...grpc.CallOption) (*MemoryGetResponse, error)
	Search(ctx context.Context, in *MemorySearchRequest, opts ...grpc.CallOption) (*MemorySearchResponse, error)
	List(ctx context.Context, in *MemoryListRequest, opts ...grpc.CallOption) (*MemoryListResponse, error)
	Delete(ctx context.Context, in *MemoryDeleteRequest, opts ...grpc.CallOption) (*MemoryDeleteResponse, error)
}

type memoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMemoryServiceClient(cc grpc.ClientConnInterface) MemoryServiceClient {
	return &memoryServiceClient{cc}
}

func (c *memoryServiceClient) Add(ctx context.Context, in *MemoryAddRequest, opts ...grpc.CallOption) (*MemoryAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryAddResponse)
	err := c.cc.Invoke(ctx, MemoryService_Add_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Get(ctx context.Context, in *MemoryGetRequest, opts ...grpc.CallOption) (*MemoryGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryGetResponse)
	err := c.cc.Invoke(ctx, MemoryService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Search(ctx context.Context, in *MemorySearchRequest, opts ...grpc.CallOption) (*MemorySearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemorySearchResponse)
	err := c.cc.Invoke(ctx, MemoryService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) List(ctx context.Context, in *MemoryListRequest, opts ...grpc.CallOption) (*MemoryListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryListResponse)
	err := c.cc.Invoke(ctx, MemoryService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Delete(ctx context.Context, in *MemoryDeleteRequest, opts ...grpc.CallOption) (*MemoryDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryDeleteResponse)
	err := c.cc.Invoke(ctx, MemoryService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MemoryServiceServer is the server API for MemoryService service.
// All implementations must embed UnimplementedMemoryServiceServer
// for forward compatibility.
type MemoryServiceServer interface {
	Add(context.Context, *MemoryAddRequest) (*MemoryAddResponse, error)
	Get(context.Context, *MemoryGetRequest) (*MemoryGetResponse, error)
	Search(context.Context, *MemorySearchRequest) (*MemorySearchResponse, error)
	List(context.Context, *MemoryListRequest) (*MemoryListResponse, error)
	Delete(context.Context, *MemoryDeleteRequest) (*MemoryDeleteResponse, error)
	mustEmbedUnimplementedMemoryServiceServer()
}

// UnimplementedMemoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMemoryServiceServer struct{}

func (UnimplementedMemoryServiceServer) Add(context.Context, *MemoryAddRequest) (*MemoryAddResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedMemoryServiceServer) Get(context.Context, *MemoryGetRequest) (*MemoryGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMemoryServiceServer) Search(context.Context, *MemorySearchRequest) (*MemorySearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedMemoryServiceServer) List(context.Context, *MemoryListRequest) (*MemoryListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedMemoryServiceServer) Delete(context.Context, *MemoryDeleteRequest) (*MemoryDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMemoryServiceServer) mustEmbedUnimplementedMemoryServiceServer() {}
func (UnimplementedMemoryServiceServer) testEmbeddedByValue()                       {}

// UnsafeMemoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MemoryServiceServer will
// result in compilation errors.
type UnsafeMemoryServiceServer interface {
	mustEmbedUnimplementedMemoryServiceServer()
}

func RegisterMemoryServiceServer(s grpc.ServiceRegistrar, srv MemoryServiceServer) {
	// If the following call panics, it indicates UnimplementedMemoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MemoryService_ServiceDesc, srv)
}

func _MemoryService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Add(ctx, req.(*MemoryAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Get(ctx, req.(*MemoryGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemorySearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Search(ctx, req.(*MemorySearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).List(ctx, req.(*MemoryListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Delete(ctx, req.(*MemoryDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MemoryService_ServiceDesc is the grpc.ServiceDesc for MemoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MemoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.MemoryService",
	HandlerType: (*MemoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _MemoryService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MemoryService_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _MemoryService_Search_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MemoryService_List_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MemoryService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	StateService_Get_FullMethodName     = "/aidememory.StateService/Get"
	StateService_Set_FullMethodName     = "/aidememory.StateService/Set"
	StateService_List_FullMethodName    = "/aidememory.StateService/List"
	StateService_Delete_FullMethodName  = "/aidememory.StateService/Delete"
	StateService_Clear_FullMethodName   = "/aidememory.StateService/Clear"
	StateService_Cleanup_FullMethodName = "/aidememory.StateService/Cleanup"
)

// StateServiceClient is the client API for StateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StateServiceClient interface {
	Get(ctx context.Context, in *StateGetRequest, opts ...grpc.CallOption) (*StateGetResponse, error)
	Set(ctx context.Context, in *StateSetRequest, opts ...grpc.CallOption) (*StateSetResponse, error)
	List(ctx context.Context, in *StateListRequest, opts ...grpc.CallOption) (*StateListResponse, error)
	Delete(ctx context.Context, in *StateDeleteRequest, opts ...grpc.CallOption) (*StateDeleteResponse, error)
	Clear(ctx context.Context, in *StateClearRequest, opts ...grpc.CallOption) (*StateClearResponse, error)
	Cleanup(ctx context.Context, in *StateCleanupRequest, opts ...grpc.CallOption) (*StateCleanupResponse, error)
}

type stateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStateServiceClient(cc grpc.ClientConnInterface) StateServiceClient {
	return &stateServiceClient{cc}
}

func (c *stateServiceClient) Get(ctx context.Context, in *StateGetRequest, opts ...grpc.CallOption) (*StateGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateGetResponse)
	err := c.cc.Invoke(ctx, StateService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Set(ctx context.Context, in *StateSetRequest, opts ...grpc.CallOption) (*StateSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateSetResponse)
	err := c.cc.Invoke(ctx, StateService_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) List(ctx context.Context, in *StateListRequest, opts ...grpc.CallOption) (*StateListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateListResponse)
	err := c.cc.Invoke(ctx, StateService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Delete(ctx context.Context, in *StateDeleteRequest, opts ...grpc.CallOption) (*StateDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateDeleteResponse)
	err := c.cc.Invoke(ctx, StateService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Clear(ctx context.Context, in *StateClearRequest, opts ...grpc.CallOption) (*StateClearResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateClearResponse)
	err := c.cc.Invoke(ctx, StateService_Clear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Cleanup(ctx context.Context, in *StateCleanupRequest, opts ...grpc.CallOption) (*StateCleanupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateCleanupResponse)
	err := c.cc.Invoke(ctx, StateService_Cleanup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StateServiceServer is the server API for StateService service.
// All implementations must embed UnimplementedStateServiceServer
// for forward compatibility.
type StateServiceServer interface {
	Get(context.Context, *StateGetRequest) (*StateGetResponse, error)
	Set(context.Context, *StateSetRequest) (*StateSetResponse, error)
	List(context.Context, *StateListRequest) (*StateListResponse, error)
	Delete(context.Context, *StateDeleteRequest) (*StateDeleteResponse, error)
	Clear(context.Context, *StateClearRequest) (*StateClearResponse, error)
	Cleanup(context.Context, *StateCleanupRequest) (*StateCleanupResponse, error)
	mustEmbedUnimplementedStateServiceServer()
}

// UnimplementedStateServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStateServiceServer struct{}

func (UnimplementedStateServiceServer) Get(context.Context, *StateGetRequest) (*StateGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedStateServiceServer) Set(context.Context, *StateSetRequest) (*StateSetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedStateServiceServer) List(context.Context, *StateListRequest) (*StateListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedStateServiceServer) Delete(context.Context, *StateDeleteRequest) (*StateDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedStateServiceServer) Clear(context.Context, *StateClearRequest) (*StateClearResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedStateServiceServer) Cleanup(context.Context, *StateCleanupRequest) (*StateCleanupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Cleanup not implemented")
}
func (UnimplementedStateServiceServer) mustEmbedUnimplementedStateServiceServer() {}
func (UnimplementedStateServiceServer) testEmbeddedByValue()                      {}

// UnsafeStateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StateServiceServer will
// result in compilation errors.
type UnsafeStateServiceServer interface {
	mustEmbedUnimplementedStateServiceServer()
}

func RegisterStateServiceServer(s grpc.ServiceRegistrar, srv StateServiceServer) {
	// If the following call panics, it indicates UnimplementedStateServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StateService_ServiceDesc, srv)
}

func _StateService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Get(ctx, req.(*StateGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Set(ctx, req.(*StateSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).List(ctx, req.(*StateListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Delete(ctx, req.(*StateDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Clear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Clear(ctx, req.(*StateClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateCleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Cleanup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Cleanup(ctx, req.(*StateCleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StateService_ServiceDesc is the grpc.ServiceDesc for StateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.StateService",
	HandlerType: (*StateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _StateService_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _StateService_Set_Handler,
		},
		{
			MethodName: "List",
			Handler:    _StateService_List_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _StateService_Delete_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _StateService_Clear_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _StateService_Cleanup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	DecisionService_Set_FullMethodName     = "/aidememory.DecisionService/Set"
	DecisionService_Get_FullMethodName     = "/aidememory.DecisionService/Get"
	DecisionService_List_FullMethodName    = "/aidememory.DecisionService/List"
	DecisionService_History_FullMethodName = "/aidememory.DecisionService/History"
)

// DecisionServiceClient is the client API for DecisionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DecisionServiceClient interface {
	Set(ctx context.Context, in *DecisionSetRequest, opts ...grpc.CallOption) (*DecisionSetResponse, error)
	Get(ctx context.Context, in *DecisionGetRequest, opts ...grpc.CallOption) (*DecisionGetResponse, error)
	List(ctx context.Context, in *DecisionListRequest, opts ...grpc.CallOption) (*DecisionListResponse, error)
	History(ctx context.Context, in *DecisionHistoryRequest, opts ...grpc.CallOption) (*DecisionHistoryResponse, error)
}

type decisionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDecisionServiceClient(cc grpc.ClientConnInterface) DecisionServiceClient {
	return &decisionServiceClient{cc}
}

func (c *decisionServiceClient) Set(ctx context.Context, in *DecisionSetRequest, opts ...grpc.CallOption) (*DecisionSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionSetResponse)
	err := c.cc.Invoke(ctx, DecisionService_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decisionServiceClient) Get(ctx context.Context, in *DecisionGetRequest, opts ...grpc.CallOption) (*DecisionGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionGetResponse)
	err := c.cc.Invoke(ctx, DecisionService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decisionServiceClient) List(ctx context.Context, in *DecisionListRequest, opts ...grpc.CallOption) (*DecisionListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionListResponse)
	err := c.cc.Invoke(ctx, DecisionService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decisionServiceClient) History(ctx context.Context, in *DecisionHistoryRequest, opts ...grpc.CallOption) (*DecisionHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecisionHistoryResponse)
	err := c.cc.Invoke(ctx, DecisionService_History_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DecisionServiceServer is the server API for DecisionService service.
// All implementations must embed UnimplementedDecisionServiceServer
// for forward compatibility.
type DecisionServiceServer interface {
	Set(context.Context, *DecisionSetRequest) (*DecisionSetResponse, error)
	Get(context.Context, *DecisionGetRequest) (*DecisionGetResponse, error)
	List(context.Context, *DecisionListRequest) (*DecisionListResponse, error)
	History(context.Context, *DecisionHistoryRequest) (*DecisionHistoryResponse, error)
	mustEmbedUnimplementedDecisionServiceServer()
}

// UnimplementedDecisionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDecisionServiceServer struct{}

func (UnimplementedDecisionServiceServer) Set(context.Context, *DecisionSetRequest) (*DecisionSetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedDecisionServiceServer) Get(context.Context, *DecisionGetRequest) (*DecisionGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDecisionServiceServer) List(context.Context, *DecisionListRequest) (*DecisionListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDecisionServiceServer) History(context.Context, *DecisionHistoryRequest) (*DecisionHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method History not implemented")
}
func (UnimplementedDecisionServiceServer) mustEmbedUnimplementedDecisionServiceServer() {}
func (UnimplementedDecisionServiceServer) testEmbeddedByValue()                         {}

// UnsafeDecisionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DecisionServiceServer will
// result in compilation errors.
type UnsafeDecisionServiceServer interface {
	mustEmbedUnimplementedDecisionServiceServer()
}

func RegisterDecisionServiceServer(s grpc.ServiceRegistrar, srv DecisionServiceServer) {
	// If the following call panics, it indicates UnimplementedDecisionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DecisionService_ServiceDesc, srv)
}

func _DecisionService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).Set(ctx, req.(*DecisionSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecisionService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).Get(ctx, req.(*DecisionGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecisionService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).List(ctx, req.(*DecisionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecisionService_History_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecisionHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecisionServiceServer).History(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DecisionService_History_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecisionServiceServer).History(ctx, req.(*DecisionHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DecisionService_ServiceDesc is the grpc.ServiceDesc for DecisionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DecisionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.DecisionService",
	HandlerType: (*DecisionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _DecisionService_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DecisionService_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DecisionService_List_Handler,
		},
		{
			MethodName: "History",
			Handler:    _DecisionService_History_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	MessageService_Send_FullMethodName  = "/aidememory.MessageService/Send"
	MessageService_List_FullMethodName  = "/aidememory.MessageService/List"
	MessageService_Ack_FullMethodName   = "/aidememory.MessageService/Ack"
	MessageService_Prune_FullMethodName = "/aidememory.MessageService/Prune"
)

// MessageServiceClient is the client API for MessageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MessageServiceClient interface {
	Send(ctx context.Context, in *MessageSendRequest, opts ...grpc.CallOption) (*MessageSendResponse, error)
	List(ctx context.Context, in *MessageListRequest, opts ...grpc.CallOption) (*MessageListResponse, error)
	Ack(ctx context.Context, in *MessageAckRequest, opts ...grpc.CallOption) (*MessageAckResponse, error)
	Prune(ctx context.Context, in *MessagePruneRequest, opts ...grpc.CallOption) (*MessagePruneResponse, error)
}

type messageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageServiceClient(cc grpc.ClientConnInterface) MessageServiceClient {
	return &messageServiceClient{cc}
}

func (c *messageServiceClient) Send(ctx context.Context, in *MessageSendRequest, opts ...grpc.CallOption) (*MessageSendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageSendResponse)
	err := c.cc.Invoke(ctx, MessageService_Send_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) List(ctx context.Context, in *MessageListRequest, opts ...grpc.CallOption) (*MessageListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageListResponse)
	err := c.cc.Invoke(ctx, MessageService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) Ack(ctx context.Context, in *MessageAckRequest, opts ...grpc.CallOption) (*MessageAckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageAckResponse)
	err := c.cc.Invoke(ctx, MessageService_Ack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) Prune(ctx context.Context, in *MessagePruneRequest, opts ...grpc.CallOption) (*MessagePruneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessagePruneResponse)
	err := c.cc.Invoke(ctx, MessageService_Prune_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageServiceServer is the server API for MessageService service.
// All implementations must embed UnimplementedMessageServiceServer
// for forward compatibility.
type MessageServiceServer interface {
	Send(context.Context, *MessageSendRequest) (*MessageSendResponse, error)
	List(context.Context, *MessageListRequest) (*MessageListResponse, error)
	Ack(context.Context, *MessageAckRequest) (*MessageAckResponse, error)
	Prune(context.Context, *MessagePruneRequest) (*MessagePruneResponse, error)
	mustEmbedUnimplementedMessageServiceServer()
}

// UnimplementedMessageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMessageServiceServer struct{}

func (UnimplementedMessageServiceServer) Send(context.Context, *MessageSendRequest) (*MessageSendResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedMessageServiceServer) List(context.Context, *MessageListRequest) (*MessageListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedMessageServiceServer) Ack(context.Context, *MessageAckRequest) (*MessageAckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ack not implemented")
}
func (UnimplementedMessageServiceServer) Prune(context.Context, *MessagePruneRequest) (*MessagePruneResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Prune not implemented")
}
func (UnimplementedMessageServiceServer) mustEmbedUnimplementedMessageServiceServer() {}
func (UnimplementedMessageServiceServer) testEmbeddedByValue()                        {}

// UnsafeMessageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageServiceServer will
// result in compilation errors.
type UnsafeMessageServiceServer interface {
	mustEmbedUnimplementedMessageServiceServer()
}

func RegisterMessageServiceServer(s grpc.ServiceRegistrar, srv MessageServiceServer) {
	// If the following call panics, it indicates UnimplementedMessageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MessageService_ServiceDesc, srv)
}

func _MessageService_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageSendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Send(ctx, req.(*MessageSendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).List(ctx, req.(*MessageListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageAckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Ack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Ack(ctx, req.(*MessageAckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_Prune_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagePruneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Prune(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Prune_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Prune(ctx, req.(*MessagePruneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MessageService_ServiceDesc is the grpc.ServiceDesc for MessageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MessageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.MessageService",
	HandlerType: (*MessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _MessageService_Send_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MessageService_List_Handler,
		},
		{
			MethodName: "Ack",
			Handler:    _MessageService_Ack_Handler,
		},
		{
			MethodName: "Prune",
			Handler:    _MessageService_Prune_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	TaskService_Create_FullMethodName   = "/aidememory.TaskService/Create"
	TaskService_Get_FullMethodName      = "/aidememory.TaskService/Get"
	TaskService_List_FullMethodName     = "/aidememory.TaskService/List"
	TaskService_Claim_FullMethodName    = "/aidememory.TaskService/Claim"
	TaskService_Complete_FullMethodName = "/aidememory.TaskService/Complete"
	TaskService_Update_FullMethodName   = "/aidememory.TaskService/Update"
)

// TaskServiceClient is the client API for TaskService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskServiceClient interface {
	Create(ctx context.Context, in *TaskCreateRequest, opts ...grpc.CallOption) (*TaskCreateResponse, error)
	Get(ctx context.Context, in *TaskGetRequest, opts ...grpc.CallOption) (*TaskGetResponse, error)
	List(ctx context.Context, in *TaskListRequest, opts ...grpc.CallOption) (*TaskListResponse, error)
	Claim(ctx context.Context, in *TaskClaimRequest, opts ...grpc.CallOption) (*TaskClaimResponse, error)
	Complete(ctx context.Context, in *TaskCompleteRequest, opts ...grpc.CallOption) (*TaskCompleteResponse, error)
	Update(ctx context.Context, in *TaskUpdateRequest, opts ...grpc.CallOption) (*TaskUpdateResponse, error)
}

type taskServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskServiceClient(cc grpc.ClientConnInterface) TaskServiceClient {
	return &taskServiceClient{cc}
}

func (c *taskServiceClient) Create(ctx context.Context, in *TaskCreateRequest, opts ...grpc.CallOption) (*TaskCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskCreateResponse)
	err := c.cc.Invoke(ctx, TaskService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) Get(ctx context.Context, in *TaskGetRequest, opts ...grpc.CallOption) (*TaskGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskGetResponse)
	err := c.cc.Invoke(ctx, TaskService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) List(ctx context.Context, in *TaskListRequest, opts ...grpc.CallOption) (*TaskListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskListResponse)
	err := c.cc.Invoke(ctx, TaskService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) Claim(ctx context.Context, in *TaskClaimRequest, opts ...grpc.CallOption) (*TaskClaimResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskClaimResponse)
	err := c.cc.Invoke(ctx, TaskService_Claim_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) Complete(ctx context.Context, in *TaskCompleteRequest, opts ...grpc.CallOption) (*TaskCompleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskCompleteResponse)
	err := c.cc.Invoke(ctx, TaskService_Complete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) Update(ctx context.Context, in *TaskUpdateRequest, opts ...grpc.CallOption) (*TaskUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskUpdateResponse)
	err := c.cc.Invoke(ctx, TaskService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskServiceServer is the server API for TaskService service.
// All implementations must embed UnimplementedTaskServiceServer
// for forward compatibility.
type TaskServiceServer interface {
	Create(context.Context, *TaskCreateRequest) (*TaskCreateResponse, error)
	Get(context.Context, *TaskGetRequest) (*TaskGetResponse, error)
	List(context.Context, *TaskListRequest) (*TaskListResponse, error)
	Claim(context.Context, *TaskClaimRequest) (*TaskClaimResponse, error)
	Complete(context.Context, *TaskCompleteRequest) (*TaskCompleteResponse, error)
	Update(context.Context, *TaskUpdateRequest) (*TaskUpdateResponse, error)
	mustEmbedUnimplementedTaskServiceServer()
}

// UnimplementedTaskServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskServiceServer struct{}

func (UnimplementedTaskServiceServer) Create(context.Context, *TaskCreateRequest) (*TaskCreateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTaskServiceServer) Get(context.Context, *TaskGetRequest) (*TaskGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTaskServiceServer) List(context.Context, *TaskListRequest) (*TaskListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTaskServiceServer) Claim(context.Context, *TaskClaimRequest) (*TaskClaimResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Claim not implemented")
}
func (UnimplementedTaskServiceServer) Complete(context.Context, *TaskCompleteRequest) (*TaskCompleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Complete not implemented")
}
func (UnimplementedTaskServiceServer) Update(context.Context, *TaskUpdateRequest) (*TaskUpdateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTaskServiceServer) mustEmbedUnimplementedTaskServiceServer() {}
func (UnimplementedTaskServiceServer) testEmbeddedByValue()                     {}

// UnsafeTaskServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskServiceServer will
// result in compilation errors.
type UnsafeTaskServiceServer interface {
	mustEmbedUnimplementedTaskServiceServer()
}

func RegisterTaskServiceServer(s grpc.ServiceRegistrar, srv TaskServiceServer) {
	// If the following call panics, it indicates UnimplementedTaskServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TaskService_ServiceDesc, srv)
}

func _TaskService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Create(ctx, req.(*TaskCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Get(ctx, req.(*TaskGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).List(ctx, req.(*TaskListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_Claim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskClaimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Claim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Claim_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Claim(ctx, req.(*TaskClaimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_Complete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Complete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Complete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Complete(ctx, req.(*TaskCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).Update(ctx, req.(*TaskUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskService_ServiceDesc is the grpc.ServiceDesc for TaskService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.TaskService",
	HandlerType: (*TaskServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _TaskService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TaskService_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TaskService_List_Handler,
		},
		{
			MethodName: "Claim",
			Handler:    _TaskService_Claim_Handler,
		},
		{
			MethodName: "Complete",
			Handler:    _TaskService_Complete_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _TaskService_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}

const (
	HealthService_Check_FullMethodName = "/aidememory.HealthService/Check"
)

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthServiceClient interface {
	Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthService_Check_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility.
type HealthServiceServer interface {
	Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthServiceServer struct{}

func (UnimplementedHealthServiceServer) Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}
func (UnimplementedHealthServiceServer) testEmbeddedByValue()                       {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	// If the following call panics, it indicates UnimplementedHealthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_Check_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Check(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aidememory.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _HealthService_Check_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aidememory.proto",
}
